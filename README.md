# Working skeleton to start a backend for your pet project in kotlin

Working skeleton for an application with the following libraries, configuration, and
examples:
- Spring boot 3.x
- junit 5, junit 4 and Cucumber, Jacoco
- kotlin tests and freeSpecs tests
- Integration of H2 in memory
- Integration of SQLite with Spring boot
- ktlint, detekt and precommits
- CI/CD with Github actions
- Integration of Sonarqube
- Deployment in Azure webapp
- Docker image, github actions and deployment it in the container register
- Environment configuration
- Wiremock example
- Swagger (OpenApi)
- Logs
- GraphQL example with apollo and Spring boot

You have examples of tests (only examples to start and understand the technology)

# Description of the folders and files

- .github : workflow for github actions with CI/CD. Deployment in Azure webapp
- config: detket.yml => here you could create rules for detket. Now empty
- scripts: pre-commit script used in every commit
- .env: file with the environment variables (examples)
- build.gradle: the file with the tasks you can use and dependencies. Tasks:
  - installGitHook => allow you to install the pre-commit
  - test => executing cucumber and all the kind of tests
  - ktlintFormat => ktlint (linter)
  - jacocoTestReport => you can create coverage reports with Jacoco
  - jacocoTestCoverageVerification => verification of rules with Jacoco
  - sonar => execute sonarqube
  - detekt => execute detekt (linter)
- mysqlite.sqlite => db autogenerated when you activate SQLite
- start.sh => script to start the service in the docker image (basic configuration, the same you do in local)
- src
  - main.kotlin.com.
    - shoppinglist => some dummy examples for the test examples
      - application.dummy => Dummy service, controller, repository and entity for spring boot examples
      - location => Dummy DTOs for graphql examples
    - common. An exension to use the logs
    - configuration. Example for consuming enviroment variables from spring boot
    - resources
      - db.migration: for flyaway and migration (To be developed)
      - graphql => example with types, queries and mutations for graphql
      - application.properties => properties for spring boot:
        - Security
        - Consume enviroment variables from the .env
        - configuration of DB depending of the .env
        - configuration of graphql
      - logback-spring.xml => configuration of logs
    - test ==> examples with tests 
      - resources=> dummy example for BDD (.feature)
      - com.shoppinglist
        - acceptance: configuration of cucumber for acceptance tests and combination with Spring boot
        - application: classic spring boot end to tests and other similar examples with FreeSpec and GraphQL.
          - Example consuming enviroment variables from the tests
        - controllers: classic example of test for controllers in spring boot
          - Example with Mockk
        - integration: example with JPA (test of DB) and Wiremock (test of external services)
        - unit: examples of unit tests:
          - using Free Specs framework (kotest)
          - Free specs but with the context of Spring 
          - Junit Jupiter
          - JUnit Jupiter with the context of spring
# The working skeleton Step by step

## Spring boot and kotlin
Here you have a tutorial to create a spring boot from Zero
https://spring.io/guides/tutorials/spring-boot-kotlin/

For the spring boot configuration we could create it with https://start.spring.io  or with intellij.
Once, we are going to create the project with the following parameters:

- gradle with groovy
- kotlin
  and some libraries as for example:
  - Spring web
  - security
  - graphql
  - ...
    You will see the dependencies in  the build.gradle file
``` groovy
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-graphql'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'com.fasterxml.jackson.module:jackson-module-kotlin'
    implementation 'org.flywaydb:flyway-core'
    implementation 'org.jetbrains.kotlin:kotlin-reflect'
    developmentOnly 'org.springframework.boot:spring-boot-devtools'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework:spring-webflux'
    testImplementation 'org.springframework.graphql:spring-graphql-test'
    testImplementation 'org.springframework.security:spring-security-test'
}
```

We are using the JDK 18. So, we would need to see the compatibility matrix for gradle:

https://docs.gradle.org/current/userguide/compatibility.html

our gradle version should be the 7.5. We can see it in:
```
gradle --version
------------------------------------------------------------
Gradle 7.5.1
------------------------------------------------------------

Build time:   2022-08-05 21:17:56 UTC
Revision:     d1daa0cbf1a0103000b71484e1dbfe096e095918

Kotlin:       1.6.21
Groovy:       3.0.10
Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021
JVM:          18.0.1.1 (Oracle Corporation 18.0.1.1+2-6)
OS:           Windows 11 10.0 amd64
```
You could have a different version of gradle installed in the project.

```
gradlew --version
------------------------------------------------------------
Gradle 7.5.1
------------------------------------------------------------

Build time:   2022-08-05 21:17:56 UTC
Revision:     d1daa0cbf1a0103000b71484e1dbfe096e095918

Kotlin:       1.6.21
Groovy:       3.0.10
Ant:          Apache Ant(TM) version 1.10.11 compiled on July 10 2021
JVM:          18.0.1.1 (Oracle Corporation 18.0.1.1+2-6)
OS:           Windows 11 10.0 amd64
```
if you want to change it, you will need to change the configuration file .\gradle\gradle-wrapper.properties
and a new version will be downloaded.
```
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
```
Also, you should change the build.gradle in the following

```
group = 'com.shoppinglist'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '18' <== 
....
tasks.withType(KotlinCompile) {
    kotlinOptions {
        freeCompilerArgs = ['-Xjsr305=strict']
        jvmTarget = '18' <==
    }
}
...
```

## Testing Strategy
With Spring we will have several types of tests.
- Unit tests
- Integration tests
- Controller tests
  https://www.baeldung.com/kotlin/spring-boot-testing

Our test strategy for this working skeleton is:
- Acceptance tests with cucumber. The main idea is to use for Acceptance tests and ATDD
- Application tests. Really, they are very similar to Acceptance tests but without cucumber. Surely, for this example we could avoid this kind of test. We would want to configure them with graphql. Two options:
  - FreeSpeecs
  - Junit 5.x
- Controllers. To be sure we are covering the controllers. Spring offer this part. We would need to learn what is the best practices here, because the acceptace tests are covering this part. When we should use them?
- Integration tests. Integration with external collaborators
  - external endpoints
  - database
- Unit tests. Only unit tests. The idea would be not to be coupled to spring. But we include the spring and context configuration
  - Two options: FreeSpeecs, Junit 5.x
  - With context and without context
    - doubles with Mockk
    - Assertions with AssertJ
### Acceptance tests: Cucumber with spring configuration
1) You need to create the first dummy feature in
   src/test/resources/cucumber/features/dummy.feature

``` gherkin
Feature: Dummy Feature

  Scenario: Dummy Scenario
    Given a dummy given
    When a dummy thing happens
    Then a dummy result happens too
```

2) We need to create the steps and the runner to work with junit
```kotlin
package com.shoppinglist.acceptance

package atm.account.steps

import io.cucumber.junit.Cucumber
import io.cucumber.junit.CucumberOptions
import org.junit.runner.RunWith

//https://github.com/jecklgamis/cucumber-jvm-kotlin-example/blob/main/src/test/kotlin/runner/ExampleFeatureTest.kt

@RunWith(Cucumber::class)
@CucumberOptions(
    features = ["classpath:cucumber/features/dummy.feature"],
    glue = ["classpath:com/shoppinglist/acceptance"],
    plugin = ["pretty", "json:target/jsonReports/acceptance.json", "html:target/cucumber/html", "html:target/cucumber/acceptance.html"]
)
class CucumberAppTestRunner
```

We need some dependencies in our .gradle
```gherkin    
    testImplementation 'io.cucumber:cucumber-java:7.11.1'
    testImplementation 'io.cucumber:cucumber-junit:7.11.1'
    testImplementation 'org.junit.vintage:junit-vintage-engine:5.9.2'
    testImplementation 'io.cucumber:cucumber-junit-platform-engine:7.11.1'
```
https://github.com/jecklgamis/cucumber-jvm-kotlin-example/blob/main/src/test/kotlin/runner/ExampleFeatureTest.kt

Take into account, cucumber runs with junit 4, and we need compatibility with junit 5,so
we will need the junit.vintaje and the plarform-engine

In addition, you will ne to take into account the cucumber test, (Aceptance test), will be
very similar to the application test, so we should configure them for this.

```
package com.shoppinglist.acceptance

import com.shoppinglist.application.ShoppingListBackendKotApplication
import io.cucumber.spring.CucumberContextConfiguration
import org.springframework.boot.test.context.SpringBootTest


@CucumberContextConfiguration
@SpringBootTest(classes = [(ShoppingListBackendKotApplication::class)])
class CucumberSpringContextConfiguration {
}
```
### Application tests
with the @SpringBootTest you can load the service and all the context.

https://www.baeldung.com/kotlin/spring-boot-testing

When you are creating application test, you load the service
and the main idea is to test the service in a end to end way.

You could use FreeSpec.

The key in this class of tests is the notation @SpringBootTest which
allow to load the context and the service.

The application test, by using cucumber, we will call them "acceptance tests". But,
the concept is the same, the only difference is we are using cucumber for the tests.

You can see it in the Cucumber configuration explaination.
### Application tests and the problem with the database

After creating a dummy entity and maybe because we are using flyway, when the context loads, spring boot miss
a database. With the objective to make it works, we configure it with a H2 database. We will see if we want to
change it in the future.

To do this, we should configure the application.yml with:

``` typical configuration
spring.datasource.driver-class-name= org.h2.Driver
spring.datasource.url=jdbc:h2:mem:localhost;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username= admin
spring.datasource.password=
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create
```
and you only have to include the following dependency. The driver for h2 in the build.gradle

```
    implementation 'com.h2database:h2'
```

These sentences are very important for JPA:
spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create

In the example we are using H2, and the table will be in memory. So, in this way, the scheme will be
self-created depending on the entities


You have more information here: https://stackoverflow.com/questions/51221777/failed-to-configure-a-datasource-url-attribute-is-not-specified-and-no-embedd
### Application tests and the problem of the login

Well, you have configurated spring boot with security, so, you will need to login to access to the api. You will see, when
you access to http://localhost:8080, that you will see a screen to login.
https://spring.io/guides/gs/securing-web/
https://www.baeldung.com/spring-security-login
https://reflectoring.io/spring-security/

if we remove the following library
```
implementation 'org.springframework.boot:spring-boot-starter-security'
```
you won't have the problem, but also you won't have security. In this way you could access to the
http://localhost:8080/api/dummy and will receive an empty json, as part of the exmaple.

But if you activate the security, you will need to do a basic configuration.
```
spring.security.user.name = admin
spring.security.user.password = admin
``` 
In your tests, you will need to user for example :   @WithMockUser(value = "spring")

### Controller tests
If you have taken into account the previous configurations, you only will have to take into account:
1. You can double the service, by using a stub. You can use MockkBean instead MockBean, because
   you are not using already mockito
2. For the security, you could use @WithMockUser, and you will able to call the endpoint
3. with mockmvc you will call the controller, testing only the part of the call

``` kotlin
@WebMvcTest
@ContextConfiguration(classes = [(ShoppingListBackendKotApplication::class)])
class ExampleControllerTestClassicSpringBoot(@Autowired val mockMvc: MockMvc) {

    @MockkBean
    lateinit var dummyService: DummyService

    @WithMockUser(value = "spring")
    @Test
    fun this_is_an_example_with_mvc() {
        every {dummyService.get()} returns DummyEntity()
        mockMvc.perform(get("http://localhost:8080//api/dummy")).
            andExpect(status().isOk)
    }
}
```
For FreeSpecs it is the same thing, but be careful with the configuration of dependencies. See the previous
recommendations.

### JPA Tests - Integration tests

There are some tips to take into account:
- We use EnableAutoconfiguration and ComponentScan, because there is an
  error in intellij, where in spite of working, the error with the autowire
  and the respository is something that only can be solved with this notations.
- Review the configuration of the H2, because in other case it is not going to work.
- The context configuration is neccesary to work.
  @DataJpaTest
``` kotlin
@DataJpaTest
@ContextConfiguration(classes = [(ShoppingListBackendKotApplication::class)])
@ComponentScan("com.shoppinglist.application.dummy")
@EnableAutoConfiguration
class ExampleJPAIntegrationTestClassicSpring {
    @Autowired
    lateinit var entityManager: TestEntityManager

    @Autowired
    lateinit var repository: DummyRepository

    @Test
    fun dummyExampleOfIntegrationTestWithDB() {
        val dummyEntity = DummyEntity()
        entityManager.persist(dummyEntity)
        entityManager.flush()
        val theSameDummyEntity = this.repository.findAll().toList();
        assertThat(theSameDummyEntity.size).isEqualTo(1)
        assertThat(theSameDummyEntity[0]).isEqualTo(dummyEntity)
    }
}

```
### Wiremock
#### Without the support of junit or spring configuration
https://www.baeldung.com/introduction-to-wiremock
https://github.com/wiremock/wiremock

Basicly, to start with wiremock you need to include this dependency:
```
testImplementation 'com.github.tomakehurst:wiremock:2.27.2'
```

```
WireMockServer wireMockServer = new WireMockServer(String host, int port);

```

Seems there is some no compatibility with spring boot:
https://groups.google.com/g/wiremock-user/c/knTaDyBY70Q

You need to use the version Beta to avoid these problems:
```
 testImplementation 'com.github.tomakehurst:wiremock:3.0.0-beta-8'
```


https://howtodoinjava.com/spring-boot2/resttemplate/resttemplate-get-example/

You will need to create a simple test class and include:
```
wireMockServer = WireMockServer(<port>) -> to create the instance of mockserver
wireMockServer.start()
wireMockServer.stop()
wireMockServer!!.resetRequests()
wireMockServer!!.verify(1, getRequestedFor(urlEqualTo("/dummyIntegration")))
```

You have an example in Test->Integration->ExampleWiremockWithoutSupportOfFrameworks

#### with kotest extension
https://wiremock.org/docs/solutions/kotlin/
https://github.com/kotest/kotest-extensions-wiremock

#### with spring boot
https://wiremock.org/docs/solutions/spring-boot/
https://medium.com/cuddle-ai/testing-spring-boot-application-using-wiremock-and-junit-5-d514a47ab931

### Unit tests without application context

We can create the first unit test with junit 5, jupiter. it is the default
testing library with spring boot. You will se you don't have this reference in the
gradle.build file.

``` kotlin
package com.shoppinglist.unit

import org.junit.jupiter.api.Test

class ExampleUnitTestJunit {
    @Test
    fun `it should be true` () {
        assert(true);
    }
}

You could see the version of junit you are using in the project, in the
part of "External libraries". In our cases we have the version 5.9.2
* junit-jupiter
* junit-jupiter-api
* junit-jupiter-engine
* junit-jupiter-params
* junit-platform-commins:1.9.2
* junit-platform-engine: 1.9.2

and mockito, but we won't use it.

```
But in our case, we want to use for unit tests other library:
(in gradle.build)
```
dependencies {
 ...
    testImplementation 'io.mockk:mockk:1.13.4'
    testImplementation 'org.assertj:assertj-core:3.24.2'
    testImplementation 'org.jetbrains.kotlin:kotlin-test'
    testImplementation 'io.kotest:kotest-runner-junit5:5.6.1'
}
```
we will include the kotest-runer-junit 5 and for mocking we will use
mockk. Also, we want to use mockk

With kotest-runner-junit5 we could use the FreeSpec tests

NOTE: if you want to see the test working in the terminal, you should
add a new plugin:

```
plugins {
 ...
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'com.adarshr.test-logger' version '3.2.0'
}
...
tasks.named('test') {
    testlogger {
        useJUnitPlatform()
    }
}
```
You have more information about it here:
https://plugins.gradle.org/plugin/com.adarshr.test-logger
You could customize the output.

There are more ways to configure it, but it is the simpler. More information here:
https://stackoverflow.com/questions/3963708/gradle-how-to-display-test-results-in-the-console-in-real-time

```
gradlew clean test <- execute with information every time (in other case, don't show the test if there is not changes)
gradlew test -i  <- execute with more information. Usually irrelevant

```
NOTE: Some tests, moreover, the default test could load the context and services.
It is because they use the notation @SpringBootTest in the test. But this kind of unit
test doesn't load anything and they are very fast to run.

### Unit tests with application context
https://www.baeldung.com/spring-5-junit-config
https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/ContextConfiguration.html

Some unit tests will need to load the application context. You can use the notation:
@SpringJUnitConfig in the class or @ContextConfiguration

### MockK, kotest and assertions
https://gradlehero.com/how-to-exclude-gradle-dependencies/
https://www.baeldung.com/kotlin/kotest

We will need mocking capabilities for our tests and Mockito is the default mocking service in
Spring boot. The recomendation is to exclude the mockito-core dependency.

You can see the dependencies in "External libraries" where you can see:
- mockito-core
- mockito-junit-jupiter

testImplementation 'org.springframework.boot:spring-boot-starter-test'

```
dependencies {
    //testImplementation 'io.kotest:kotest-runner-junit5-jvm:5.6.2'  <-- not neccesary
    testImplementation 'io.mockk:mockk:1.13.5'
    testImplementation 'io.kotest:kotest-runner-junit5:5.6.2'
    testImplementation 'io.kotest:kotest-assertions-core:$version'
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.2")
    
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.mockito', module: 'mockito-core'   
        exclude group: 'org.mockito', module: 'mockito-junit-jupiter'     
    }
    testImplementation 'com.ninja-squad:springmockk:4.0.2'
    testImplementation 'org.assertj:assertj-core:3.24.2'
    ...
     
}
```
Every library has a reason:
* io.mockk (https://mockk.io/). This is the mocking library for Kotlin. Here you have all the documentation.
  * mockk. In the maven repository, the last version is the 1.13.5 at this moment
* com.ninja-squad (https://github.com/Ninja-Squad/springmockk). This is the spring support for mockk
  * springmockk:3.0.1. With this library you could have MockBean and Spybewan
* io.kotest:(https://kotest.io/docs/quickstart/) This is the test framework for kotlin
  - kotest-runner-junit5-jvm:5.6.2 ==> compatibility with junit 5
  - kotest-runner-junit5: 5.6.2 ==>  (the same) compatibility with junit you need it to run the tests with junit
    NOTE: The kotest-runner-junit5 install the following dependencies:
    - i.kotest:kotest-assertions-api-jvm
    - o.kotest:kotest-assertions-core-jvm
    - io.kotest:kotest-shared-jvm
    - io.kotest:kotest-common-jvm
    - io.kotest:kotest-extensions-jvm
    - io.kotest:kotest-framework-api-jvm
    - io.kotest:kotest-framework-concurrency-jvm
    - io.kotest:kotest-framework-discovery-jvm
    - io.kotest:kotest-framework-engine-jvm
    - io.kotest:kotest-runner-junit5-jvm
    -
But when you install the kotest-runner-junit-jvm, the following dependencies are installed:
- i.kotest:kotest-assertions-api-jvm
- io.kotest:kotest-assertions-core-jvm
- io.kotest:kotest-shared-jvm
- io.kotest:kotest-common-jvm
- io.kotest:kotest-extensions-jvm
- io.kotest:kotest-framework-api-jvm
- io.kotest:kotest-framework-concurrency-jvm
- io.kotest:kotest-framework-discovery-jvm
- io.kotest:kotest-framework-engine-jvm
- io.kotest:kotest-runner-junit5-jvm
  In both cases, we have installed the same dependencies, so we should include only one of them
* org.assertj
  * assertj-core: https://joel-costigliola.github.io/assertj/assertj-core-quick-start.html
    * With assertjcore we have better assertion.
    * Kotest have some assertions

Regarding io.kotest.extensions:kotest-extensions-spring, you need to take into account in the last
versions of spring you will need it for FreeSpecs tests. In other way, they won't able to load the context.
https://stackoverflow.com/questions/53277045/how-does-kotlintest-test-spring-boot-application
### Differences in the assertions with assertJ and kotests

Certain different aspects. If you don't want to user assertj, you could remove the dependency
https://kotest.io/docs/assertions/assertions.html

```
   @Test
    fun it_should_be_true_example_classic_springboot_appTest() {
        assertThat(true).isTrue() // AssertJ
        true shouldBe true // kotest assertions
    }
```

## Linters and precommits
### Precommit
Basicly, when you commit something, you wants to be sure some scripts are executed.

You have a file in the folder script called pre-commit with the following code:

``` bash 
#!/bin/sh
echo "▶️ Running pre-commit checks..."

./gradlew ktlint
EXIT_CODE=$?

if [ ${EXIT_CODE} -ne 0 ]; then
    echo "😵 Pre Commit checks failed. Please fix the above issues before committing"
    exit ${EXIT_CODE}
else
    echo "✅ Pre Commit checks passed, no problems found"
    exit 0
fi
```

Basicly, in this script you are executing a task in the build.gradle which will execute
ktlint.

You could include here you want.

This only works if you execute the task in graddle to execute it. This tasks will
install the hooks

```
task installGitHooks(type: Copy, group: "git-hooks") {
    from new File(rootProject.rootDir, 'scripts/pre-commit')
    into { new File(rootProject.rootDir, '.git/hooks')}
    fileMode 0775
}
check.dependsOn installGitHooks
```
NOTE: <Inmediatly after the task of ktlint, include>
check.dependsOn ktlint

Once you have executed .\gradlew intallGitHooks, every time you execute commit
the script will be executed.

### ktlint 
A new dependency in the build.gradle

```
...
configurations {
    ktlint
}

...

dependencies {
runtimeOnly 'com.pinterest.ktlint:ktlint-core:0.49.1'

..
}
...
task ktlint(type: JavaExec, group: "verification") {
    description = "Check Kotlin code style."
    classpath = configurations.ktlint
    main = "com.pinterest.ktlint.Main"
    args "src/**/*.kt"
}

task ktlintFormat(type: JavaExec, group: "formatting") {
    description = "Fix Kotlin code style deviations."
    classpath = configurations.ktlint
    main = "com.pinterest.ktlint.Main"
    args "-F", "src/**/*.kt"
}
```
And with this, you could execute : "gradlew ktlint" and "gradlew ktlintFormat"

With java > 16 you are going to have some problems and you should change certain things
in the ktlintFormat to work properly:

``` gradle
...
task ktlintFormat(type: JavaExec, group: "verification") {
jvmArgs "--add-opens", "java.base/java.lang=ALL-UNNAMED"
description = "Fix Kotlin code style deviations."
classpath = configurations.ktlint
mainClass = "com.pinterest.ktlint.Main"
args "-F", "src/**/*.kt"
}
```

In addition, you could add a pre-commit:

```
task installGitHooks(type: Copy, group: "git-hooks") {
    from new File(rootProject.rootDir, 'scripts/pre-commit')
    into { new File(rootProject.rootDir, '.git/hooks')}
    fileMode 0775
}
check.dependsOn installGitHooks
...
<Inmediatly after the task of ktlint, include>
check.dependsOn ktlint
```

In addition, you will need a folder with a file with the following:
scripts/pre-commit
``` bash
#!/bin/sh
echo "▶️ Running pre-commit checks..."

./gradlew ktlint
EXIT_CODE=$?

if [ ${EXIT_CODE} -ne 0 ]; then
    echo "😵 Pre Commit checks failed. Please fix the above issues before committing"
    exit ${EXIT_CODE}
else
    echo "✅ Pre Commit checks passed, no problems found"
    exit 0
fi
```

NOTE: The only problem that I have found it you need to install the pre-commit using
.\gradlew installGitHooks

### ktlint - other library which I could make works - just information
https://github.com/jeremymailen/kotlinter-gradle

You only have to add the plugin
```gradle
plugins {
    ...
    id 'org.jmailen.kotlinter' version '3.14.0'
}
```
and you will able to execute:

```
.\gradlew lintkotlin  <-- it will only report the format problems 
.\gradle formatKotlin <- it will change the format
```

In addition, you could create a hoock for Git. Adding the following
in the build.gradle
```gradle
tasks.named('check') {
    dependsOn 'installKotlinterPrePushHook'
}
```
This hook, will execute the lintKotlin and if there are errors, formatKotlin.

the problem I have found with this approach is if you execute .\gradlew test, it has stopped
working.

### Detekt
https://github.com/detekt/detekt
Detekt is code analysis for kotlin. I supose we will use it for sonarqube.
With this we look for code smells.

This is the website:
https://detekt.dev/
https://detekt.dev/docs/intro/
https://hofstede-matheus.medium.com/improve-code-quality-with-ktlint-detekt-and-git-hooks-d173722594e4
https://plugins.gradle.org/plugin/io.gitlab.arturbosch.detekt

Configuramos el .build
```
plugins {
    ..
    id 'org.jetbrains.kotlin.jvm' version '1.8.21' <-- make a look to the version
    id 'org.jetbrains.kotlin.plugin.spring' version '1.8.21' <-- make a look to the version
    ...
    id "io.gitlab.arturbosch.detekt" version "1.23.0"
}

...
dependencies {
    implementation 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.23.0'
    ...
    
}


detekt {
    config = files("$projectDir/config/detekt/detekt.yml")
    input = files("src/main/java", "src/main/kotlin")
}
```
And you will need to create a empty file in config/detekt/detekt.yml

You will create the rules here

You have more information in: https://detekt.dev/docs/introduction/configurations/

You can execute with:

```
.\gradlew detekt

```
## Coverage and Sonarqube

### Jacoco coverage
For this, you will need to include code in your build.gradle

https://medium.com/@ranjeetsinha/jacoco-with-kotlin-dsl-f1f067e42cd0
https://docs.gradle.org/current/userguide/jacoco_plugin.html

``` gradle
..
plugins {
  ...
    id 'jacoco'
}
...

jacocoTestReport {
    dependsOn test
    executionData tasks.withType(Test).findAll { it.state.executed }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [])
        }))
    }
    reports {
        xml.setEnabled(true)
        html.setEnabled(true)
        html.destination file("${buildDir}/jacocoHtml")
    }
}

jacocoTestCoverageVerification {
    dependsOn test
    executionData tasks.withType(Test).findAll { it.state.executed }
    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [])
        }))
    }
    violationRules {
        rule {
            limit {
                counter = 'INSTRUCTION'
                minimum = 0.8
            }
            limit {
                counter = 'BRANCH'
                minimum = 0.8
            }
            limit {
                counter = 'LINE'
                minimum = 0.8
            }
            limit {
                counter = 'METHOD'
                minimum = 0.8
            }
            limit {
                counter = 'CLASS'
                minimum = 0.8
            }
        }
    }
}
```

And now, you could execute:
```ssh
.\gradlew test --> the coverage will be generated in the build/jacoco folder
.\gradle jacocoTestReport --> the reports will be generated in html in the build/jacocoHTML
.\gradlew jacocoTestCoverageVerification --> you could use some quality gates.
```

### Sonarqube
You will need to create a sonar-project properties

```
sonar.projectKey=danielvillahermosadominguez_shopping_list_backend_kot
sonar.organization=danielvillahermosadominguez

sonar.projectName=shopping_list_backend_kot
sonar.projectVersion=latest

sonar.sources=src/main/kotlin
sonar.tests=src/test/kotlin
sonar.language=java
sonar.sourceEncoding=UTF-8

sonar.coverage.jacoco.xmlReportPaths= build/reports/jacoco/test/jacocoTestReport.xml
sonar.junit.reportsPath=build/test-results/test/TEST-*.xml
#sonar.coverage.exclusions=src/main/kotlin

```
In our case, we did it in the pipeline with github actions and we don't need to use this file. 
We directly configured it in the build.gradle

```kotlin
sonar {
    properties {
        property "sonar.projectKey", "danielvillahermosadominguez_shopping_list_backend_kot"
        property "sonar.organization", "danielvillahermosadominguez"
        property "sonar.host.url", "https://sonarcloud.io"
        property "sonar.projectVersion", "latest"
        property "sonar.sources", "src/main/kotlin"
        property "sonar.tests", "src/test/kotlin"
        property "sonar.coverage.jacoco.xmlReportPaths", "build/reports/jacoco/test/jacocoTestReport.xml"
        property "sonar.junit.reportsPath", "build/test-results/test/TEST-*.xml"
    }
}
```

## Swagger (OpenAPI)
https://www.tutorialspoint.com/spring_boot/spring_boot_enabling_swagger2.htm
https://www.baeldung.com/kotlin/swagger-spring-rest-api
https://levelup.gitconnected.com/adding-swagger-to-kotlin-spring-48b930e03ed5

You will need to include:
```
implementation('org.springdoc:springdoc-openapi-starter-webmvc-ui:2.0.3')
```

And you will access with:  http://localhost:8080/swagger-ui.html

Also you can configurate it with a special configuration.

You could include in the application.properties:
```yaml
springdoc.swagger-ui.path=/swagger-ui.html
```

## Logs
https://www.baeldung.com/kotlin/kotlin-logging-library

We need to include:
```
implementation 'io.github.microutils:kotlin-logging-jvm:3.0.5'
```
create a file logback-spring.xml in main->kotlin->resources with the following code:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %replace(%msg){'Bearer [^ ]+', '*****'}%n</pattern>
        </encoder>
    </appender>

    <appender name="json" class="ch.qos.logback.core.ConsoleAppender">
        <layout class="ch.qos.logback.contrib.json.classic.JsonLayout">
            <jsonFormatter
                    class="ch.qos.logback.contrib.jackson.JacksonJsonFormatter">
                <!-- <prettyPrint>true</prettyPrint> -->
            </jsonFormatter>
            <timestampFormat>yyyy-MM-dd' 'HH:mm:ss.SSS</timestampFormat>
        </layout>
    </appender>

    <springProfile name="!production">
        <root name="logger" level="INFO">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>

    <springProfile name="production">
        <!-- just exemplary, change to what suits your needs in production usage -->
        <root name="logger" level="INFO">
            <appender-ref ref="CONSOLE" />
        </root>
    </springProfile>

    <logger name="com.shoppinglist" level="INFO"/>
</configuration>
```

You could create a helper:
```kotlin
fun makeLogger(func: () -> Unit): KLogger {
    func() // for test coverage
    return KotlinLogging.logger(func)
}

```

And call it in everywhere:
```kotlin
private val logger = makeLogger {}
    ...
class ShoppingListBackendKotApplication

fun main(args: Array<String>) {
    logger.info("STARTING APPLICATION....")
    runApplication<ShoppingListBackendKotApplication>(*args)
    logger.info("RUNNING APPLICATION....")
}

```
## Local persistency
### Environnent variables
You need to include this, in the application.properties
```
spring.config.import=optional:file:.env[.properties]
```
https://www.baeldung.com/kotlin/read-env-variables
``` java
val env = System.getenv("HOME")
assertNotNull(env)
```
NOTE: I haven't gotten to use it with a .env file. It is not working.
https://www.baeldung.com/spring-boot-properties-env-variables
https://stackoverflow.com/questions/73053852/spring-boot-env-variables-in-application-properties

Although you could try to use it:
https://github.com/paulschwarz/spring-dotenv
``` gradle
implementation 'me.paulschwarz:spring-dotenv:2.3.0'
configurations.testImplementation.exclude(group: 'me.paulschwarz', module: 'spring-dotenv')
```

With this, the best approach are the following cases:
1) Be sure your app is going to scan the packages. For example, if we use
   other folder for the class which will contain the configuration we should:
``` gradle
@SpringBootApplication(scanBasePackages = ["com.shoppinglist.application", "com.shoppinglist.configuration"])
class ShoppingListBackendKotApplication

fun main(args: Array<String>) {
    runApplication<ShoppingListBackendKotApplication>(*args)
}
```

2) You will need to create a configuration class
```gradle
@Configuration
@ConfigurationPropertiesScan
class AppConfiguration(
    @Value("\${environment.exampleVariable}") private val exampleVariable: String?,
) {
    fun getExampleVariable():String? = exampleVariable
}
```

3) You should get the variables in your application.properties
```
...
environment.exampleVariable=${EXAMPLE_VARIABLE}
..
```
4) where you .env file contains
```
EXAMPLE_VARIABLE=Example
```
In addition, you will need to take into account, if you have the configuration in a folder
out of the main folder, you will need to scan these packages for the autowire.

Other solution is to have this structure of packages:
```
com.shoppinglist
    +application
        +dummy
            ....
        + configuration
            AppConfiguration
        ShoppingListBackendKotApplication.kt
```
But if you have other folder out of the application, you will need:

``
@SpringBootApplication(scanBasePackages = ["com.shoppinglist.application", "com.shoppinglist.configuration"])
class ShoppingListBackendKotApplication
``

And at the end, to access to this properties

```
 @Autowired
  private val appConfiguration: AppConfiguration? = null
```

### SQLite
https://adinugroho.medium.com/using-sqlite-with-spring-boot-kotlin-73b365f6c576
https://www.baeldung.com/spring-boot-sqlite
You must to include this dependencies
```
    implementation 'org.xerial:sqlite-jdbc:3.40.1.0'
    implementation 'org.hibernate.orm:hibernate-community-dialects'
```

And in the environment .env
```yaml
#SQLITE Configuration
SPRING_JPA_DATABASE_PLATFORM=org.hibernate.community.dialect.SQLiteDialect
SPRING_JPA_HIBERNATE_DDL_AUTO=update
SPRING_DATASOURCE_URL=jdbc:sqlite:mydb.sqlite
SPRING_DATASOURCE_DRIVER_CLASS_NAME=org.sqlite.JDBC
SPRING_DATASOURCE_USERNAME=admin
SPRING_DATASOURCE_PASSWORD=admin
SPRING_JPA_GENERATE_DLL=true
#H2 Configuration
#SPRING_JPA_DATABASE_PLATFORM=
#SPRING_JPA_HIBERNATE_DDL_AUTO=create
#SPRING_DATASOURCE_URL=jdbc:h2:mem:localhost;DB_CLOSE_ON_EXIT=FALSE
#SPRING_DATASOURCE_DRIVER_CLASS_NAME=org.h2.Driver
#SPRING_DATASOURCE_USERNAME=admin
#SPRING_DATASOURCE_PASSWORD=
#SPRING_JPA_GENERATE_DLL=true
```

and in the application.properties
```
spring.datasource.driver-class-name= ${SPRING_DATASOURCE_DRIVER_CLASS_NAME}
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.username= ${SPRING_DATASOURCE_USERNAME}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD}
spring.jpa.generate-ddl=${SPRING_JPA_GENERATE_DLL}
spring.jpa.hibernate.ddl-auto=${SPRING_JPA_HIBERNATE_DDL_AUTO}
```

## GraphQL

### The problem with graphql and Springboot 2.x or 3.x

Depending on your version of spring you will have to use different libraries. 
For us, it was a little confuse at the begining and we hope this information is useful for you.


### graphql - (for spring 3.x)
https://howtodoinjava.com/spring-boot/spring-boot-graphql-tutorial/
https://stackoverflow.com/questions/75921067/spring-boot-graphql-querymapping-not-being-called
You have to take into account that if you have spring 2.x or you have spring 3.x you
will need different libraries (see the section before)

So, you will need to include your libraries in the gradle.build
```
dependencies {
...
    implementation 'org.springframework.boot:spring-boot-starter-graphql:3.0.4'
    implementation 'org.springframework.boot:spring-boot-starter-web'
..
```

The motivation to use this library is:
* Schema first. The schema will be portable
* Minimal boilerplate: the dtos will be works with the schemas, you don't have to maintain both things.
* Type discovery or class discovery of mutations and queries.
* Class validation.
* Unit testing. You graphql schema is independent of your data model, this makes your classes simple and extremely
  testeable

To start with kotlin and spring boot, they show you this link: https://github.com/graphql-java-kickstart/graphql-spring-boot

To know what is your kotlin version you will need:
(https://discuss.kotlinlang.org/t/how-do-i-know-which-kotlin-used/25178)
```bash
kotlinc -version
info: kotlinc-jvm 1.8.0 (JRE 18.0.1.1+2-6)
```

In addition, in you build.gradle could see the following plugins:
``` 
  id 'org.jetbrains.kotlin.jvm' version '1.8.21'
  id 'org.jetbrains.kotlin.plugin.spring' version '1.8.21'
```

According this documentation, you should need to have the kotlin version in you gradle.properties. This file
you can have in serveral places, the first found in one of these locations wins:
- in the directory of GRADLE_USER_HOME
- in the project directory
- in the graddle installation directory
  For example, in our case, we don't have this gradle.properties in any of these directories, but have you seen,
  we have the libraries with the 1.8.x in the build.gradle and we have installed kotlin in
- C:\tools\kotlin\kotlinc\bin\kotlinc
- we have a KOTLIN_HOME variable pointing to this directory
- And our gradle is in local installed, but we use the wrapper in the directory with
  the gradle-wrapper.properties with the 7.5.1

Regarding our spring version, is the 3.0.6. Because we are establishing it int he build.gradle
in the plugins:
```
plugins {
id 'org.springframework.boot' version '3.0.6'
...

```
In the application.properties you can use:
```
graphql.servlet.websocket.enabled= true
graphql.servlet.mapping=/graphql
graphql.servlet.cors-enabled= true
graphql.servlet.cors.allowed-origins= '*'
graphql.servlet.cors.allowed-methods= GET, HEAD, POST
graphql.servlet.exception-handlers-enabled=true
graphql.servlet.context-setting= PER_REQUEST_WITH_INSTRUMENTATION
graphql.servlet.async.enabled=true
graphql.playground.enabled= true
graphql.playground.mapping= /playground
graphql.playground.settings.schema.disable-comments= false
spring.graphql.graphiql.enabled=true
```
if you include a new variable in your .env file: ENABLE_GRAPHQL_PLAYGROUND = true

you could activate the https://www.gatsbyjs.com/docs/how-to/querying-data/running-queries-with-graphiql/
what is an interface to develop with
graphql.graphiql.enabled = true
/graphiql but your server should be available.

On the other hand, the playground should be available in /playground
By default:
/playground
/graphql
/subscriptions

De hecho aqui funciona el http://localhost:8080/graphiql

Now we need to create the object types. In resources/locations.graphqls we write it
and a simple query
```graphql
type DummyLocation {
    id: String!
    name: String!
    address: String!
}

type Query {
    findAllLocations: [DummyLocation]!
}

type Mutation {
    addLocation(
        id:String!,
        name:String!,
        address:String!
    ): DummyLocation
}
```
By default the schemas must have the extension .grapqls and the folder by default
is main/resources/graphql, but you could change this folder with this property, for
example
spring.graphql.schema.locations=/graphql_other_folder

You will need the model. So we will include:

Location
``` kotlin
package com.shoppinglist.application.location

class Location(
    val id: String,
    val name: String,
    val address: String,
)
```
Query resolver
``` kotlin
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.graphql.data.method.annotation.SchemaMapping
import org.springframework.stereotype.Controller

@Controller
class LocationQueryResolver {
    //@SchemaMapping(typeName = "Query", value = "findAllLocations")
    @QueryMapping
    fun findAllLocations(): List<DummyLocation> {
        return listOf(
            DummyLocation("1","name1", "address1"),
            DummyLocation("2","name2", "address2"),
        )
    }
}
```
Mutation resolver
``` kotlin

```
You could use the SqchemaMapping, it is other way to to the same. remember
to include as controller, in other case it is not going to work.
http://localhost:8080/graphql

with the following body:
```
query {
    findAllLocations {
        id
        name
        address
    } 
}
``` 
```
mutation {
  addLocation(
    id:"1",
  	name:"name4",
  	address:"address4") {
    id
    name
    address
  }
  
}
```
And for testing the API with postman for example you could:
https://www.apollographql.com/blog/tooling/graphql-ide/how-to-use-graphql-with-postman/
(you only need to use the graphql option)

The official documentation is in: https://docs.spring.io/spring-graphql/docs/current/reference/html/
For testing:

testImplementation 'org.springframework.graphql:spring-graphql-test:1.2.0'
https://dev.to/imphilippesimo/testing-your-graphql-apis-in-a-spring-boot-app-ki7
https://www.baeldung.com/spring-boot-graphql-spqr
https://gist.github.com/steklopod/634d5bc55758ac61fdadd029119c8864

You will need this dependency:
testImplementation 'org.springframework.boot:spring-boot-starter-webflux'

and you will need to use
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
in other case it will fail

Other interesting thing is to syncrhonize with your frontend the types:
https://olivier-thomas.medium.com/from-backend-to-frontend-typed-application-with-graphql-2d52d61b946a
https://stackoverflow.com/questions/60692082/recommended-way-for-sharing-types-between-frontend-and-nodejs-graphql
https://github.com/dotansimha/graphql-code-generator
In the case of vue, you will need to use the graphql generator, it is a library for this purpose.
